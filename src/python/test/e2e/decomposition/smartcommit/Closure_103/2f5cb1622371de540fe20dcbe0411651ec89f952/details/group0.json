REFACTOR
refactor: Refactor code structure ...
------------
1:0
Update MarkerAnnotation.
Update MethodDeclaration "getTypeWithProperty".
Change Type "JSType" To: "ObjectType".

{
  "relativeFilePath": "src/com/google/javascript/jscomp/DisambiguateProperties.java",
  "startLine": 736,
  "endLine": 736,
  "version": "BASE",
  "contentType": "CODE",
  "codeSnippet": [
    "    @Override public JSType getTypeWithProperty(String field, JSType type) {"
  ]
}
{
  "relativeFilePath": "src/com/google/javascript/jscomp/DisambiguateProperties.java",
  "startLine": 736,
  "endLine": 736,
  "version": "CURRENT",
  "contentType": "CODE",
  "codeSnippet": [
    "    @Override public ObjectType getTypeWithProperty(String field, JSType type) {"
  ]
}
------------
1:1
Add InfixExpression.
Add VariableDeclarationStatement "maybeType".
Add IfStatement.

{
  "relativeFilePath": "src/com/google/javascript/jscomp/DisambiguateProperties.java",
  "startLine": 760,
  "endLine": 759,
  "version": "BASE",
  "contentType": "EMPTY",
  "codeSnippet": []
}
{
  "relativeFilePath": "src/com/google/javascript/jscomp/DisambiguateProperties.java",
  "startLine": 761,
  "endLine": 772,
  "version": "CURRENT",
  "contentType": "CODE",
  "codeSnippet": [
    "      // If the property does not exist on the referenced type but the original",
    "      // type is an object type, see if any subtype has the property.",
    "      if (foundType == null) {",
    "        ObjectType maybeType = ObjectType.cast(",
    "            registry.getGreatestSubtypeWithProperty(type, field));",
    "        // getGreatestSubtypeWithProperty does not guarantee that the property",
    "        // is defined on the returned type, it just indicates that it might be,",
    "        // so we have to double check.",
    "        if (maybeType != null && maybeType.hasOwnProperty(field)) {",
    "          foundType = maybeType;",
    "        }",
    "      }"
  ]
}
------------
4:0
Add MethodDeclaration "testSupertypeReferenceOfSubtypeProperty".

{
  "relativeFilePath": "test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java",
  "startLine": 586,
  "endLine": 585,
  "version": "BASE",
  "contentType": "EMPTY",
  "codeSnippet": []
}
{
  "relativeFilePath": "test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java",
  "startLine": 587,
  "endLine": 608,
  "version": "CURRENT",
  "contentType": "CODE",
  "codeSnippet": [
    "  public void testSupertypeReferenceOfSubtypeProperty() {",
    "    String externs = \"\"",
    "        + \"/** @constructor */ function Ext() {}\"",
    "        + \"Ext.prototype.a;\";",
    "    String js = \"\"",
    "        + \"/** @constructor */ function Foo() {}\\n\"",
    "        + \"/** @constructor \\n@extends Foo*/ function Bar() {}\\n\"",
    "        + \"Bar.prototype.a;\\n\"",
    "        + \"/** @param {Foo} foo */\"",
    "        + \"function foo(foo) {\\n\"",
    "        + \"  var x = foo.a;\\n\"",
    "        + \"}\\n\";",
    "    String result = \"\"",
    "        + \"function Foo() {}\\n\"",
    "        + \"function Bar() {}\\n\"",
    "        + \"Bar.prototype.Bar_prototype$a;\\n\"",
    "        + \"function foo(foo) {\\n\"",
    "        + \"  var x = foo.Bar_prototype$a;\\n\"",
    "        + \"}\\n\";",
    "    testSets(false, externs, js, result, \"{a=[[Bar.prototype]]}\");",
    "  }",
    ""
  ]
}
------------
4:1
Add MethodDeclaration "testCustomInherits".

{
  "relativeFilePath": "test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java",
  "startLine": 893,
  "endLine": 892,
  "version": "BASE",
  "contentType": "EMPTY",
  "codeSnippet": []
}
{
  "relativeFilePath": "test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java",
  "startLine": 916,
  "endLine": 935,
  "version": "CURRENT",
  "contentType": "CODE",
  "codeSnippet": [
    "  public void testCustomInherits() {",
    "    String js = \"Object.prototype.inheritsFrom = function(shuper) {\\n\" +",
    "        \"  /** @constructor */\\n\" +",
    "        \"  function Inheriter() { }\\n\" +",
    "        \"  Inheriter.prototype = shuper.prototype;\\n\" +",
    "        \"  this.prototype = new Inheriter();\\n\" +",
    "        \"  this.superConstructor = shuper;\\n\" +",
    "        \"};\\n\" +",
    "        \"function Foo(var1, var2, strength) {\\n\" +",
    "        \"  Foo.superConstructor.call(this, strength);\\n\" +",
    "        \"}\" +",
    "        \"Foo.inheritsFrom(Object);\";",
    "",
    "    String externs = \"\" +",
    "        \"function Function(var_args) {}\" +",
    "        \"/** @return {*} */Function.prototype.call = function(var_args) {};\";",
    "",
    "    testSets(false, externs, js, js, \"{}\");",
    "  }",
    ""
  ]
}
------------
3:1
Add Code.

{
  "relativeFilePath": "test/com/google/javascript/jscomp/ControlFlowAnalysisTest.java",
  "startLine": 1248,
  "endLine": 1248,
  "version": "BASE",
  "contentType": "BLANKLINE",
  "codeSnippet": [
    ""
  ]
}
{
  "relativeFilePath": "test/com/google/javascript/jscomp/ControlFlowAnalysisTest.java",
  "startLine": 1254,
  "endLine": 1254,
  "version": "CURRENT",
  "contentType": "BLANKLINE",
  "codeSnippet": [
    "  "
  ]
}
------------
0:0
Add SwitchCase.

{
  "relativeFilePath": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
  "startLine": 893,
  "endLine": 892,
  "version": "BASE",
  "contentType": "EMPTY",
  "codeSnippet": []
}
{
  "relativeFilePath": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
  "startLine": 894,
  "endLine": 894,
  "version": "CURRENT",
  "contentType": "CODE",
  "codeSnippet": [
    "      case Token.INSTANCEOF:"
  ]
}
------------
3:0
Add MethodDeclaration "testInstanceOf".

{
  "relativeFilePath": "test/com/google/javascript/jscomp/ControlFlowAnalysisTest.java",
  "startLine": 1242,
  "endLine": 1241,
  "version": "BASE",
  "contentType": "EMPTY",
  "codeSnippet": []
}
{
  "relativeFilePath": "test/com/google/javascript/jscomp/ControlFlowAnalysisTest.java",
  "startLine": 1243,
  "endLine": 1248,
  "version": "CURRENT",
  "contentType": "CODE",
  "codeSnippet": [
    "  public void testInstanceOf() {",
    "    String src = \"try { x instanceof 'x' } catch (e) { }\";",
    "    ControlFlowGraph<Node> cfg = createCfg(src, true);",
    "    assertCrossEdge(cfg, Token.EXPR_RESULT, Token.BLOCK, Branch.ON_EX);",
    "  }",
    "  "
  ]
}
------------
0:1
Update MethodInvocation To InfixExpression.

{
  "relativeFilePath": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
  "startLine": 899,
  "endLine": 899,
  "version": "BASE",
  "contentType": "CODE",
  "codeSnippet": [
    "      if (mayThrowException(c)) {"
  ]
}
{
  "relativeFilePath": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
  "startLine": 900,
  "endLine": 900,
  "version": "CURRENT",
  "contentType": "CODE",
  "codeSnippet": [
    "      if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {"
  ]
}
------------
2:0
Add MethodDeclaration "testInstanceOfThrowsException".

{
  "relativeFilePath": "test/com/google/javascript/jscomp/CheckUnreachableCodeTest.java",
  "startLine": 138,
  "endLine": 137,
  "version": "BASE",
  "contentType": "EMPTY",
  "codeSnippet": []
}
{
  "relativeFilePath": "test/com/google/javascript/jscomp/CheckUnreachableCodeTest.java",
  "startLine": 139,
  "endLine": 143,
  "version": "CURRENT",
  "contentType": "CODE",
  "codeSnippet": [
    "  public void testInstanceOfThrowsException() {",
    "    testSame(\"function f() {try { if (value instanceof type) return true; } \" +",
    "             \"catch (e) { }}\");",
    "  }",
    "  "
  ]
}
